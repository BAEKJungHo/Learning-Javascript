# 객체와 객체지향 프로그래밍

## 프로퍼티 나열

객체도 컨테이너이고, 프로퍼티 나열을 지원합니다. 하지만 `순서가 보장되지 않습니다.` 즉, 객체 프로퍼티에는 순서가 없습니다.

## for ... in

```javascript
const SYM = Symbol();

const o = { a:1, b:2, c:3, [SYM]:4 };

for(let prop in o) {
  if(!0.hasOwnPorperty(prop)) continue;
  console.log(`${prop}: ${o[prop]}`);
}
```

`hasOwnProperty`는 상속된 프로퍼티가 for ...in에 나타날 위험을 제거하기 위해서 사용합니다. hasOwnProperty를 사용해야하는 이유는 다른 타입의 객체,
특히 다른 사람이 만든 객체의 프로퍼티를 나열하다 보면 예상치 못한 상황이 생길 수 있으므로 hasOwnProperty를 쓰는 습관을 들여야 좋습니다.

배열에는 for in보다 forEach나 for 루프를 사용하는 것이 좋습니다.

## Object.keys

Object.key는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환합니다.

객체에서 x로 시작하는 프로퍼티를 모두 가져오는 예제입니다.

```javascript
const o = { apple: 1, xchitl: 2, balloon: 3, guitar: 4, xylophone: 5, };

Object.keys(o)
  .filter(prop => prop.match(/^x/))
  .forEach(prop => console.log(`${prop}: ${o[prop]}`));
```

## 객체지향 프로그래밍

ES6에서는 클래스를 만드는 간편한 새 문법을 도입했습니다.

```javascript
class Car {
  constructor() {
  
  }
}
```

```javascript
const car1 = new Car();
const car2 = new Car();
```

```javascript
car1 instanceof Car // true
car1 instanceof Array / false
```

```javascript
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this.userGears = ['P', 'N, 'R', 'D'];
    this.userGear = this.userGear[0];
  }
  shift(gear) {
    if(this.userGears.indexOf(gear) < 0)
      throw new Error(`Invalid gear: ${gear}`);
    this.userGear = gear;
   }
 }
 ```
 
 ```javascript
 const car1 = new Car("Tesla", "Model S");
 const car2 = new Car("Mazda", "3i");
 
 car1.shift('D');
 car2.shift('R');
 ```
 
 ## 클래스는 함수다
 
 - ES5에서의 클래스
 
 ```javascript
 function Car(make, model) {
  this.make = make;
  this.model = model;
  this._userGears = ['P', 'N, 'R', 'D'];;
  this._userGear = this.userGears[0];
 }
 ```
 
 변수명앞에 언더바를 붙이면 해당 프로퍼티에 접근하려는 것을 눈치채고 예방할 수 있습니다.
 
 ## 정적 메서드
 
 정적 메서드는 클래스 메서드라고도 하며, 인스턴스가 아니라 클래스 자체에 묶입니다. 인스턴스 메서드에서는 this를 사용했지만 정적 메서드에서는
 클래스 이름을 사용하는것이 좋은 습관입니다.
 
 ```javascript
 class Car {
  static getNextVin() {
    return Car.nextVin++; // this.nextVin++ 으로 사용해도 되지만, Car 를 앞에 사용하면 정적 메서드라는 점을 상기하기 쉽습니다.
    
  }
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this.vin = Car.getNextVin();
  }
  static areSimilar(car1, car2) {
    return car1.make === car2.make && car1.model === car2.model;
  }
  static areSame(car1, car2) {
    return car1.vin === car2.vin;
  }
}
Car.nextVin = 0;

const car1 = new Car("Tesla", "S");
const car2 = new Car("Mazda", "3");
...
```

## 상속

자바스크립트의 상속은 한 단계로 끝나지 않습니다. 객체의 프로토타입에서 메서드를 찾지 못하면 자바스크립트는 프로토타입의 프로토타입을 검색합니다.
프로토타입 체인은 이런식으로 만들어집니다. 자바스크립트는 조건에 맞는 프로토타입을 찾을 때까지 프로토타입 체인을 계속 거슬러 올라갑니다. 
조건에 맞는 프로토타입을 찾지 못하면 에러를 일으킵니다.
클래스의 계층 구조를 만들 때 프로토타입 체인을 염두에 두면 효율적인 구조를 만들 수 있습니다.

즉, 프로토타입 체인에서 가장 적절한 위치에 메서드를 정의하는 겁니다. 

