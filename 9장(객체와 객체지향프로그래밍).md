# 객체와 객체지향 프로그래밍

## 프로퍼티 나열

객체도 컨테이너이고, 프로퍼티 나열을 지원합니다. 하지만 `순서가 보장되지 않습니다.` 즉, 객체 프로퍼티에는 순서가 없습니다.

## for ... in

```javascript
const SYM = Symbol();

const o = { a:1, b:2, c:3, [SYM]:4 };

for(let prop in o) {
  if(!0.hasOwnPorperty(prop)) continue;
  console.log(`${prop}: ${o[prop]}`);
}
```

`hasOwnProperty`는 상속된 프로퍼티가 for ...in에 나타날 위험을 제거하기 위해서 사용합니다. hasOwnProperty를 사용해야하는 이유는 다른 타입의 객체,
특히 다른 사람이 만든 객체의 프로퍼티를 나열하다 보면 예상치 못한 상황이 생길 수 있으므로 hasOwnProperty를 쓰는 습관을 들여야 좋습니다.

배열에는 for in보다 forEach나 for 루프를 사용하는 것이 좋습니다.

## Object.keys

Object.key는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환합니다.

객체에서 x로 시작하는 프로퍼티를 모두 가져오는 예제입니다.

```javascript
const o = { apple: 1, xchitl: 2, balloon: 3, guitar: 4, xylophone: 5, };

Object.keys(o)
  .filter(prop => prop.match(/^x/))
  .forEach(prop => console.log(`${prop}: ${o[prop]}`));
```

## 객체지향 프로그래밍

ES6에서는 클래스를 만드는 간편한 새 문법을 도입했습니다.

```javascript
class Car {
  constructor() {
  
  }
}
```

```javascript
const car1 = new Car();
const car2 = new Car();
```

```javascript
car1 instanceof Car // true
car1 instanceof Array / false
```

```javascript
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
    this.userGears = ['P', 'N, 'R', 'D'];
    this.userGear = this.userGear[0];
  }
  shift(gear) {
    if(this.userGears.indexOf(gear) < 0)
      throw new Error(`Invalid gear: ${gear}`);
    this.userGear = gear;
   }
 }
 ```
 
 ```javascript
 const car1 = new Car("Tesla", "Model S");
 const car2 = new Car("Mazda", "3i");
 
 car1.shift('D');
 car2.shift('R');
 ```
 
 ## 클래스는 함수다
 
 - ES5에서의 클래스
 
 ```javascript
 function Car(make, model) {
  this.make = make;
  this.model = model;
  this._userGears = ['P', 'N, 'R', 'D'];;
  this._userGear = this.userGears[0];
 }
 ```
 
 변수명앞에 언더바를 붙이면 해당 프로퍼티에 접근하려는 것을 눈치채고 예방할 수 있습니다.

