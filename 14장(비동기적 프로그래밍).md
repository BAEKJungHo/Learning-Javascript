# 비동기적 프로그래밍

비동기적 프로그래밍이 필요한 이유는 자바스크립트의 본성 때문입니다.

자바스크립트 애플리케이션은 단일 스레드에서 동작합니다. 즉, 자바스크립트는 한 번에 한 가지 일만 할 수 있습니다.

자바스크립트의 비동기적 프로그래밍에 뚜렷이 구분되는 세 가지 패러다임이 있습니다.

- 비동기적 프로그래밍의 세 가지 패러다임
  - 콜백(callback)
  - 프라미스(promise)
  - 제너레이터(generator)
  
제너레이터 자체는 비동기적 프로그래밍을 전혀 지원하지 않습니다. 제너레이터를 비동기적으로 사용하려면 프라미스나 특수한 콜백과 함께 사용해야합니다.

프라미스 역시 콜백에 의존합니다. 

사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세 가지가 있습니다.

- Ajax 호출을 비롯한 네트워크 요청
- 파일을 읽고 쓰는 등의 파일 시스템 작업
- 의도적으로 시간 지연을 사용하는 기능(알람 등)

## 콜백(callback)

콜백은 자바스크립트에서 가장 오래된 비동기적 매커니즘 입니다. 콜백은 간단히 말해 나중에 호출할 함수 입니다.
콜백 함수 자체에는 특별한 것이 전혀 없습니다. 콜백 함수도 일반적인 자바스크립트 함수일 뿐입니다. 콜백 함수는 일반적으로 다른 함수에 넘기거나 객체의
프로퍼티로 사용합니다. 드물게는 배열에 넣어서 쓸 때도 있습니다. 항상 그런것은 아니지만, 콜백은 보통 익명 함수로 사용합니다.

- 콜백 함수(callback function)
  - 나중에 호출할 함수를 의미한다.
  - 똑같은 자바스크립트 함수이다.
  - 일반적으로 익명함수로 구현된다.
  - 객체의 프로퍼티, 다른 함수에게 전달 혹은 배열에 넣어서 쓰인다.
  
setTimeout은 콜백의 실행을 지정된 밀리초만큼 지연하는 내장 함수입니다.
  
  ```javascript
  console.log("A");
  functon callbackFunc() {
    console.log("After timeout : + new Date());
  }
  console.log("B");
  setTimeout(f, 60*1000); // 1분
   console.log("C");
  ```
  
실행 결과는 A, B, C After timeout ~ 입니다.
  
비동기적 실행의 가장 큰 목적, 가장 중요한 요점은 `어떤 것도 차단하지 않는다`라는 것입니다.
  
위 코드에서 콜백함수를 익명함수로 변경해 보겠습니다.
  
  ```javascript
  setTimeout(function() {
    console.log("After timeout: " + new Date());
  }, 60*1000);
  ```
  
### setInterval과 clearInterval
  
setTimeout은 콜백 함수를 한 번만 실행하고 멈추지만, setInterval은 콜백을 정해진 주기마다 호출하며 clearInterval을 사용할 때 까지 멈추지 않습니다.

아래 예제는 분이 넘어가거나 10회째가 될 때까지 5초마다 콜백을 실행합니다.

```javascript
const start = new Date();
let i = 0;
const intervalId = setInterval(function() {
  let now = new Date();
  if(now.getMinutes() != start.getMinutes() || ++i>10)
    return clearInterval(intervalId);
  console.log(`${i}: ${now}`);
}, 5*1000);
```

setTimeout, setInterval, clearInterval은 모두 전역 객체(브라우저는 window, 노드는 global)에 정의되어 있습니다.

## 오류 우선 콜백(error-first callback)

노드가 점점 인기를 얻어가던 시기에 오류 우선 콜백이라는 패턴이 생겼습니다. 콜백을 사용하면 예외 처리가 어려워지므로, 콜백과 관련된 에러를
처리할 방법의 표준이 필요했습니다. 이에 따라 나타난 패턴이 `콜백의 첫 번째 매개변수에 에러 객체를 쓰자`는 것이었습니다.

에러가 null이나 undefined이면 에러가 없는 것입니다.

콜백에서 가장 먼저 하는 일은 `err가 참과 같은 값인지 확인하`는 것입니다. err가 참과 같은 값이면 파일을 읽는데 문제가 있다는 뜻이므로 콘솔에 오류를
보고하고 즉시 빠져나옵니다.

## 콜백 헬(callback hell)

아래 예제는 노드 앱을 만든다 가정하고, 세가지 파일의 콘텐츠를 읽고, 60초가 지난 다음 이들을 결합해 네 번째 파일에 기록하는 예제입니다.

```javascript
const fs = require('fs');

fs.readFile('a.txt', function(err, dataA) {
  if(err) console.error(err);
  fs.readFile('b.txt', function(err, dataB) {
    if(err) console.error(err);
    fs.readFile('c.txt', function(err, dataC) {
      if(err) console.error(err);
      setTimeout(function() {
        fs.writeFile('d.txt', dataA+dataB+dataC, function(err) {
          if(err) console.error(err);
        });
      }, 60*1000);
    });
  });
});
```

프로그래머들은 이런 코드를 콜백 헬이라 부릅니다. 
  
  
